# -*- coding: utf-8 -*-
"""Q3-HW02.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ObyvSfGY2oQ2W9ZM2jEYFdMob-47R1pS

### Q3

#### Libraries
"""

import numpy as np
import matplotlib.pyplot as plt
from skimage.data import shepp_logan_phantom
from skimage.transform import rescale

"""#### Loading Image"""

# Generate a 2D phantom image
image = shepp_logan_phantom()

# Rescale the image to 500*500 pixels
image = rescale(image, scale=500/image.shape[0], mode='reflect', channel_axis=None)

# Plot the image
plt.imshow(image, cmap='gray')
plt.title('Shepp-Logan modified phantom')
plt.show()

"""#### Adding Gaussian Noise"""

img = image.copy()

# Add gaussian noise
mean = 0
var = 0.3
sigma = var ** 0.5
noise = np.random.normal(mean, sigma, img.shape)
img_noisy = img + noise

# Clip the values to [0, 255]
img_noisy = np.clip(img_noisy, 0, 255)

# Convert back to uint8
#img_noisy = np.uint8(img_noisy)

plt.imshow(img_noisy, cmap='gray')
plt.title('Noisy image')
plt.show()

"""#### Filtering By Gaussian Kernel"""

# Define the Gaussian kernel
def gaussian_kernel(size, sigma):
  # Create a 2D array of zeros
  kernel = np.zeros((size, size))
  # Calculate the center coordinates
  center = size // 2
  # Loop over the kernel elements
  for i in range(size):
    for j in range(size):
      # Calculate the distance from the center
      dist = (i - center) ** 2 + (j - center) ** 2
      # Apply the Gaussian formula
      kernel[i, j] = np.exp(-dist / (2 * sigma ** 2))
  # Normalize the kernel to sum to one
  kernel /= np.sum(kernel)
  return kernel

# Define the local weighted mean filter
def local_weighted_mean_filter(image, kernel):
  # Get the image and kernel dimensions
  height, width = image.shape[:2]
  ksize = kernel.shape[0]
  kcenter = ksize // 2
  # Create an empty array for the output image
  output = np.zeros_like(image)
  # Pad the image with zeros on the borders
  padded = np.pad(image, kcenter, mode='constant')
  # Loop over the image pixels
  for i in range(height):
    for j in range(width):
      # Extract a subimage around the pixel
      subimage = padded[i:i+ksize, j:j+ksize]
      # Multiply the subimage with the kernel element-wise
      weighted = subimage * kernel
      # Sum up the weighted values and assign to the output pixel
      output[i, j] = np.sum(weighted)
  return output

kernel = gaussian_kernel(21, 3)
filtered = local_weighted_mean_filter(img_noisy, kernel)
plt.imshow(filtered , cmap='gray')
plt.title('Filtered image')
plt.show()

"""The main problem is filtering with a Gaussian kernel and local weighted mean may blur the image and reduce its sharpness and contrast

#### Filtering By BM3D
"""

!pip install bm3d

"""the BM3D algorithm works as follows:

*    In the first stage, the noisy image is divided into small blocks ofpixels. For each block, similar blocks are found in a large search window around it. The similarity is measured by the Euclidean distance between the blocks. The similar blocks are stacked together to form a 3D array.
*   The 3D array is then transformed into a sparse representation using a 3D transform such as discrete cosine transform (DCT) or wavelet transform. The sparse representation means that most of the coefficients are close to zero and only a few are significant.
*   The coefficients are then hard-thresholded, meaning that the ones below a certain threshold are set to zero and the ones above are kept unchanged. This reduces the noise while preserving the signal.
The inverse 3D transform is applied to obtain a denoised 3D array. The denoised blocks are then aggregated back to the image domain by averaging them with their overlapping counterparts. This reduces the blocking artifacts and improves the quality of the denoised image.
*   In the second stage, the denoised image from the first stage is used as a reference to find similar blocks again. The same steps as in the first stage are repeated, except that instead of hard-thresholding, a Wiener filter is applied to the coefficients. The Wiener filter is a linear filter that minimizes the mean squared error between the original and denoised signals. It adapts to the local signal and noise statistics and preserves more details than hard-thresholding.
*    The final denoised image is obtained by aggregating the denoised blocks from the second stage.
"""

import bm3d

denoised_image = bm3d.bm3d(img_noisy, sigma_psd=30/255, stage_arg=bm3d.BM3DStages.HARD_THRESHOLDING)
plt.imshow(denoised_image , cmap='gray')
plt.title('Filtered image With BM3D')
plt.show()