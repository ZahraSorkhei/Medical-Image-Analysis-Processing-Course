# -*- coding: utf-8 -*-
"""Q2-HW02.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ObyvSfGY2oQ2W9ZM2jEYFdMob-47R1pS

### Q2

#### Libraries
"""

import numpy as np
from PIL import Image, ImageOps
from matplotlib import pyplot as plt
import cv2
from tqdm import tqdm
from scipy.ndimage import convolve

"""#### Reading Images"""

image  = np.asarray(Image.open('q2.png')).astype('int')
plt.imshow(image)
plt.title('Original image')
plt.show()

"""#### Normalize pixels"""

def scale_array(array, out_range=(0, 255)):
  '''This function normalize an image between range'''
  # Assume array is a numpy array of shape (H, W)
  # Calculate the min and max of the whole array
  min_val = np.min(array)
  max_val = np.max(array)
  # Apply linear transformation
  scaled_array = (array - min_val) / (max_val - min_val) * (out_range[1] - out_range[0]) + out_range[0]
  return scaled_array
def standardImage(img):
  ''' get the absolute values of pixels and then normalize them'''
  img = np.abs(img)
  img = scale_array(img)
  return img

"""#### Test Spatial Kernel"""

hx  = 0.02 * max(300, 300)
ksize = 3
image = np.float32(image)
f = np.exp(-np.abs(np.arange(-ksize//2, ksize//2+1)[:,None] - np.arange(-ksize//2, ksize//2+1)[None,:])**2 / (2 * (hx**2)))
f = cv2.getGaussianKernel(ksize,hx)
f = f * f.T
print(f)
image_f = image - image
# apply the spatial filter to the image
for i in range(3):
    image_f[:,:,i] = scale_array(cv2.filter2D(image[:,:,i], -1, f))
plt.imshow(image_f.astype('uint8'))
plt.axis('off')
plt.savefig('q2_filtered_spatial.jpg')
plt.show()

"""#### Calculting PSNR"""

def PSNR(original, noisy, peak=255):
  """ 
  param peak: max value of pixel 8-bit image (255)
  """

  # Calculating the Mean Squared Error
  mse = np.mean(np.square(original.astype('float') -  noisy.astype('float')))

  # Calculating the Peak Signal Noise Ratio
  psnr = 10*np.log10(peak**2/mse)

  return psnr

"""#### Bilateral Filter"""

import numpy as np
import cv2

def bilateral_filter(image, ksize, hx, hg):
    # image: input image
    # ksize: kernel size
    # hx: spatial standard deviation
    # hg: range standard deviation
    # returns: filtered image

    # convert the input image to a float array

    # get image dimensions
    height, width = image.shape[:2]

    # create an empty output image
    output = np.zeros_like(image)

    # create a filter for spatial weights
    #f = np.exp(-np.abs(np.arange(-ksize//2, ksize//2+1)[:,None] - np.arange(-ksize//2, ksize//2+1)[None,:])**2 / (2 * (hx**2)))
    f = cv2.getGaussianKernel(ksize, hx)
    f = f * f.T

    # apply the spatial filter to the image
    image_f = cv2.filter2D(image, -1, f)
    window_kernel = []
    window_image = []

    # iterate over each pixel
    for i in range(height):
        for j in range(width):

            # get the current pixel value
            Ip = image_f[i,j]

            # define the window boundaries
            i_min = max(i - ksize//2, 0)
            i_max = min(i + ksize//2 + 1, height)
            j_min = max(j - ksize//2, 0)
            j_max = min(j + ksize//2 + 1, width)

            # get the window around the current pixel
            I = image_f[i_min:i_max, j_min:j_max]

            # compute the Gaussian filter for range weights
            g = np.exp(-((I - Ip)**2) / (2 * (hg**2)))
            if(i==j and j%10 == 0):
              window_kernel.append(g)
              window_image.append(I)

            #print(g.shape)
            #print(f[i_min-i+ksize//2:i_max-i+ksize//2,j_min-j+ksize//2:j_max-j+ksize//2].shape)
            # compute the bilateral filter response
            Wp = np.sum(f[i_min-i+ksize//2:i_max-i+ksize//2,j_min-j+ksize//2:j_max-j+ksize//2] * g)
            #print((f[i_min-i+ksize//2:i_max-i+ksize//2,j_min-j+ksize//2:j_max-j+ksize//2] * g).shape)
            output[i,j] = np.sum(f[i_min-i+ksize//2:i_max-i+ksize//2,j_min-j+ksize//2:j_max-j+ksize//2] * g * I) / Wp

    return output, window_kernel, window_image

"""#### Test Bilateral Filter

A bilateral filter is a smoothing filter for images that preserves edges and reduces noise. It has two parameters: hx and hg. hx is the spatial parameter that controls the size of the filter kernel. hg is the range parameter that controls how much the filter is influenced by intensity differences. Choosing hx and hg depends on the image characteristics and the desired effect. Generally, larger values of hx and hg will produce more smoothing, but may also blur edges or create artifacts. Smaller values of hx and hg will preserve more details, but may also retain more noise. A common practice is to use hx = hg = σ, where σ is the standard deviation of the Gaussian distribution used for weighting.

Another way to choose hx and hg for the bilateral filter is to use σd and σr, which are equivalent to hx and hg respectively. σd is the spatial standard deviation and σr is the range standard deviation. As σr increases, the bilateral filter becomes closer to Gaussian blur because the range Gaussian is flatter. As σd increases, the bilateral filter smooths larger features. A good choice of σd and σr depends on the image resolution and noise level. A possible method is to use σd = 2% of the image diagonal and σr = 5% of the intensity range
"""

height, width = image.shape[:2]
# sigma_s is proportional to the image size
hx  = 0.02 * max(height, width)

# sigma_r is proportional to the image intensity range
hg = 0.05 * (np.max(image) - np.min(image))

output = image - image
window_kernel= []
window_image = []
for i in range(3):
    output[:,:,i],k,w=  bilateral_filter(image[:,:,i], 3, hx, 100)
    window_kernel.append(k)
    window_image.append(w)

# A function for show an image with its kernel
def showImageKernel(i,window_image,window_kernel):
    img = np.zeros((3,3,3))
    img[:,:,0] = window_image[0][i]
    img[:,:,1] = window_image[1][i]
    img[:,:,2] = window_image[2][i]
    kernel = np.zeros((3,3,3))
    kernel[:,:,0] = window_kernel[0][i]
    kernel[:,:,1] = window_kernel[1][i]
    kernel[:,:,2] = window_kernel[2][i]
    print("Its Kernel: \n",kernel.view())
    plt.imshow(img.astype('uint8'))
    plt.axis('off')
    plt.title('Image')

showImageKernel(5,window_image,window_kernel)

showImageKernel(10,window_image,window_kernel)

showImageKernel(20,window_image,window_kernel)

"""In bilateral filtering, a window of pixels is selected around each pixel in the image, and a kernel function is applied to each pixel in that window. The kernel function is used to calculate the weighted average of the pixel values in the window, where the weights are determined by the distance between each pixel and the center pixel of the window, as well as by the difference between their intensity values. The size of the window and the kernel function used can be adjusted to control the amount of smoothing applied to the image."""

fig = plt.figure(figsize=(10, 10))
rows = 1
columns = 3
fig.add_subplot(rows, columns, 1)
plt.imshow(image.astype('uint8'))
plt.axis('off')
plt.title('Original Image')
fig.add_subplot(rows, columns, 2)
plt.imshow(image_f.astype('uint8'))
plt.axis('off')
plt.title('Spatial Filter')
fig.add_subplot(rows, columns, 3)
plt.imshow(output.astype('uint8'))
plt.axis('off')
plt.title('Bilateral Filter')

plt.imshow(output.astype('uint8'))
plt.axis('off')
plt.savefig('res_bilateral.jpg')