# -*- coding: utf-8 -*-
"""miap_hw01_q5.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1nUg0Yr2hUYo7_Bp0TZrBdnX2pk1blVir

### Q5
"""

#Import Libraries
import numpy as np
from PIL import Image, ImageOps
from numpy import asarray
from matplotlib import pyplot as plt
import cv2

#Load image and convet its type to int
image  = asarray(Image.open('q5.png')).astype('int')

#Show original image
plt.imshow(image.astype('uint8'))
plt.title('Original image')
plt.axis('off')
plt.show()

#Ù‘Find mask as every pixels is green in original image
mask = np.zeros((image.shape[0],image.shape[1]))
for i in range(image.shape[0]):
  for j in range(image.shape[1]):
    if(image[i][j][1]>=250 and image[i][j][0] ==0 and image[i][j][2]<=5):
      mask[i][j]=255

#Show mask as an image
plt.imshow(mask.astype('uint8'),cmap='gray')
plt.axis('off')
plt.savefig('q5res01.jpg')
plt.show()

# Define erosion function
def erosion(img, kernel):
    # Get image dimensions
    rows, cols = img.shape
    ksize1 = kernel.shape[0]
    ksize2 = kernel.shape[1]

    # Create output image
    output = np.zeros_like(img)

    # Get half size of the kernel
    sz1 = (ksize1 - 1) // 2
    if(ksize1 %2 == 0):
      sz1 = (ksize1) // 2
    sz2 = (ksize2 - 1) // 2
    if(ksize2 %2 == 0):
      sz2 = (ksize2) // 2

    # Loop over each pixel
    for i in range(rows):
        for j in range(cols):
            # Check if pixel is on boundary
            if i < sz1 or i >= rows-sz1 or j < sz2 or j >= cols-sz2:
                # Copy pixel as it is
                output[i,j] = img[i,j]
            else:
                # Get neighborhood by superimposing kernel
                neighborhood = img[i-sz1:i+sz1+1,j-sz2:j+sz2+1] * kernel
                
                # Check if all pixels are 255
                if np.all(neighborhood == 255):
                    # Set output pixel to 255
                    output[i,j] = 255
                else:
                    # Set output pixel to 0
                    output[i,j] = 0
    
    # Return output image
    return output

# Define dilation function
def dilation(img, kernel):
    # Get image dimensions
    rows, cols = img.shape

    # Create output image
    output = np.zeros_like(img)
    ksize1 = kernel.shape[0]
    ksize2 = kernel.shape[1]

    # Get half size of the kernel
    sz1 = (ksize1 - 1) // 2
    if(ksize1 %2 == 0):
      sz1 = (ksize1) // 2
    sz2 = (ksize2 - 1) // 2
    if(ksize2 %2 == 0):
      sz2 = (ksize2) // 2

    # Loop over each pixel
    for i in range(rows):
        for j in range(cols):
            # Check if pixel is on boundary
            if i < sz1 or i >= rows-sz1 or j < sz2 or j >= cols-sz2:
                # Copy pixel as it is
                output[i,j] = img[i,j]
            else:
                # Get neighborhood by superimposing kernel
                neighborhood = img[i-sz1:i+sz1+1,j-sz2:j+sz2+1] * kernel
                
                # Check if any pixel is 255
                if np.any(neighborhood == 255):
                    # Set output pixel to 255
                    output[i,j] = 255
                else:
                    # Set output pixel to 0
                    output[i,j] = 0
    # Return output image
    return output

#Define closing operator
def closing(image , kernel):
  return erosion(dilation(image,kernel),kernel)
def opening(image , kernel):
  return dilation(erosion(image,kernel),kernel)

mask2 = mask.astype(np.int16)
kernel2 = np.ones((13, 1), np.int16)
closing_mask2 = opening(mask2, kernel2)
plt.imshow(closing_mask2.astype('uint8'),cmap='gray')
plt.axis('off')

#We choose a kernel based on fill holes ans also keep details
kernel = np.ones((9, 7), np.int16)
# defining the closing function 
# over the image and structuring element
closing_mask = closing(closing_mask2, kernel)
# The mask and closing operation
# is shown in the window 
plt.imshow(closing_mask.astype('uint8'),cmap='gray')
plt.axis('off')
plt.savefig('q5res02.jpg')
plt.show()

#make the color of clothe red
red_clothe = np.copy(image)
for i in range(closing_mask.shape[0]):
  for j in range(closing_mask.shape[1]):
    if(closing_mask[i][j]==255):
      red_clothe[i,j,1]=0
      red_clothe[i,j,0]=255
      red_clothe[i,j,2]=0

#Show new image
plt.imshow(red_clothe.astype('uint8'))
plt.axis('off')
plt.savefig('q5res03.jpg')
plt.show()

"""To find the mask, we find the points whose first channel is zero and whose second channel is 255 and the third channel is less than 5. If the third channel is 0, the border of the dress is only obtained.


To fill the holes, we use the closing method, which according to the slides covers the empty parts between the full parts of the image. For this, we write functions for Erosion and Dilation, and according to the slides, we first apply Dilation and then apply Erosion on the image. Also for opening we first apply Erosion and then apply Dilation on the image. 



First, we apply an opening with kernel size (13,1) and then we apply a closing with kernel size (9,7). The reason for the opening is that we want the handle of the glass to be separated from the clothe, so we make it a little wider so that it doesn't fill up after closing.

To apply the mask, find in the image a non-zero value or 255 anywhere in the two-dimensional array of the mask, and set the pixel values in the second and third channels to zero and set them to 255 in the first channel.
"""