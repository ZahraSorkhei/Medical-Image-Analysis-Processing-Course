# -*- coding: utf-8 -*-
"""MIAP_HW01_Q3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Sg68pDChe7IkiOasc5ijvuarBOzZuAop

### Q3
"""

import cv2
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

gray = cv2.cvtColor(cv2.imread('q3_1.JPG'), cv2.COLOR_BGR2GRAY)

# Plot the histogram using sns.histplot
sns.histplot(gray.flatten(), kde=False)
plt.xlabel('Pixel value')
plt.ylabel('Frequency')
plt.title('Original histogram')
# Save the figure as a PNG file
plt.savefig('q3res1.jpg')

"""Normalization of an image is a process that changes the range of pixel intensity values to improve the contrast and visibility of the image. One way to normalize an image is to use histogram equalization, which is a technique that redistributes the pixel values so that the histogram of the image is more uniform. This can enhance the fine details and features of the image that may be hidden in the dark or bright regions.

To perform histogram equalization, we need to calculate the cumulative distribution function (CDF) of the pixel values, which is the sum of the probabilities of all the pixel values up to a given value. Then, we map each pixel value to a new value based on the CDF, such that the new values are evenly distributed in the range of 0 to (L-1), where L is the number of possible intensity levels. This can be done using the following formula:

$s_k = (L-1) \times sum(p_rj) \;for \;j = 0\; to\; k$

where $s_k$ is the new pixel value, $p_{rj}$ is the probability of the pixel value $r_j$, and $k$ is the original pixel value
"""

# Get the number of pixels and intensity levels
N = gray.size

L = 260
hist = np.bincount(gray.flatten(), minlength=L)
p = hist / N
# Calculate CDF
cdf = np.cumsum(p)

# Map each pixel value to a new value based on the CDF
s = (L-1) * cdf
eq = s[gray].astype(np.uint8)


plt.imshow(eq, cmap='gray')
plt.title('Equalized image')
plt.savefig('q3res2.jpg')
plt.axis('off')
plt.show()

sns.histplot(eq.flatten(), kde=False)
plt.xlabel('Pixel value')
plt.ylabel('Frequency')
plt.title('Equalized histogram')
plt.savefig('q3res3.jpg')
plt.show()

input_img = cv2.imread('q3_2.jpg')
ref = cv2.imread('q3_3.jpg')

input_img.shape

import numpy as np

def hist_match(source, template):
    # Get the unique values and their corresponding counts for the source and template images
    s_values, s_counts = np.unique(source, return_counts=True)
    t_values, t_counts = np.unique(template, return_counts=True)

    # Compute the cumulative distribution functions for the source and template images
    s_cdf = np.cumsum(s_counts).astype(np.float64)
    s_cdf /= s_cdf[-1]
    t_cdf = np.cumsum(t_counts).astype(np.float64)
    t_cdf /= t_cdf[-1]

    # Interpolate linearly to find the pixel values in the template image
    # that correspond most closely to the quantiles in the source image

    interp_t_values = np.interp(s_cdf, t_cdf, t_values)
    if interp_t_values.shape[0] <= source.max():
      interp_t_values = np.resize(interp_t_values, source.max() + 1)
    # Map the source image pixels to the interpolated values
    matched = interp_t_values[source]

    return matched

# Perform histogram matching
matched = input_img - input_img
for i in range(3):
    source = input_img[:,:,i]
    template = ref[:,:,i]
    # Perform histogram matching
    out = hist_match(source, template)
    matched[:,:,i] = out
    fig = plt.figure(figsize=(15, 5))
    rows = 1
    columns = 3
    fig.add_subplot(rows, columns, 1)
    sns.histplot(source.flatten(), kde=False)
    plt.xlabel('Pixel value')
    plt.ylabel('Frequency')
    plt.title('Original histogram'+' for '+str(i)+' channel')
    fig.add_subplot(rows, columns, 2)
    sns.histplot(template.flatten(), kde=False)
    plt.xlabel('Pixel value')
    plt.ylabel('Frequency')
    plt.title('Reference histogram')
    fig.add_subplot(rows, columns, 3)
    sns.histplot(out.flatten(), kde=False)
    plt.xlabel('Pixel value')
    plt.ylabel('Frequency')
    plt.title('Histogram after matching')
    plt.savefig('q3-3_'+'histogram-for'+'channel'+str(i+1)+'.jpg')
    plt.show()


# Convert the matched image back to uint8
matched = matched.astype(np.uint8)
from PIL import Image
im = Image.fromarray(matched)
im.save("q3-3_result.jpg")
# Display the results
fig, (ax1, ax2, ax3) = plt.subplots(nrows=1, ncols=3, figsize=(8, 3),
                                    sharex=True, sharey=True)

ax1.imshow(input_img)
ax1.set_title('Source')
ax1.axis('off')
ax2.imshow(ref)
ax2.set_title('Reference')
ax2.axis('off')
ax3.imshow(matched)
ax3.set_title('Matched')
ax3.axis('off')
plt.tight_layout()
plt.show()