# -*- coding: utf-8 -*-
"""MIAP_HW01_Q1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Sg68pDChe7IkiOasc5ijvuarBOzZuAop

### Q1

A finite difference is an expression that approximates the change in a function at a point. It can be used to estimate the derivative of a function numerically.

A backward difference uses the function values at x and x − h, where h is the step size. It is given by:

∇f(x<sub>j</sub>) = (f(x<sub>j</sub>) − f(x<sub>j-1</sub>))/(x<sub>j</sub> -x<sub>j-1</sub> )

A forward difference uses the function values at x and x + h. It is given by:

Δf(x<sub>j</sub>) = (f(x<sub>j+1</sub>) − f(x<sub>j</sub>))/(x<sub>j+1</sub> -x<sub>j</sub> )

A central difference uses the function values at x − h and x + h. It is an average of the backward and forward differences. It is given by:

δ(x<sub>j</sub>) = (f(x<sub>j+1</sub>) − f(x<sub>j-1</sub>))/(x<sub>j+1</sub> -x<sub>j-1</sub> )

The central difference has a smaller error than the backward and forward differences, because it is symmetric and cancels out the first-order error terms. The error of the central difference is of order O(h<sup>2</sup>), while the error of the backward and forward differences is of order O(h)
"""

import numpy as np
from PIL import Image, ImageOps
from numpy import asarray
from matplotlib import pyplot as plt

def find_derivative(image,mode='backward', dir ='x'):
    ''' 
    image  is input image
    mode set the gradient as backward , forward or central
    dir set if we want f_x or f_y
    '''
    n = image.shape[0]
    d = image - image
    if(mode == 'backward'):
      if(dir == 'x'):
        for i in range(0,n):
          for j in range(0,n):
            if(i==0):
              d[i][j] = image[i][j]
              break
            d[i][j] = int(image[i][j]) - int(image[i-1][j])
      if(dir == 'y'):
        for i in range(0,n):
          for j in range(0,n):
            if(j==0):
              d[i][j] = int(image[i][j])
            d[i][j] = int(image[i][j]) - int(image[i][j-1])
    if(mode == 'forward'):
      if(dir == 'x'):
        for i in range(0,n):
          for j in range(0,n):
            if(i==n-1):
              d[i][j] = image[i][j]
              break
            d[i][j] = int(image[i+1][j]) - int(image[i][j])
      if(dir == 'y'):
        for i in range(0,n):
          for j in range(0,n):
            if(j==n-1):
              d[i][j] = image[i][j]
              break
            d[i][j] = int(image[i][j+1]) - int(image[i][j])
    if(mode == 'central'):
      if(dir == 'x'):
        for i in range(0,n):
          for j in range(0,n):
            if(i==0 or i==n-1):
              d[i][j] = image[i][j]
              break
            d[i][j] = int(image[i+1][j]) - int(image[i-1][j])
      if(dir == 'y'):
        for i in range(0,n):
          for j in range(0,n):
            if(j==n-1):
              d[i][j] = image[i][j]
              break
            d[i][j] = int(image[i][j+1]) - int(image[i][j-1])
    return d

def scale_array(array, out_range=(0, 255)):
  '''This function normalize an image between range'''
  # Assume array is a numpy array of shape (H, W)
  # Calculate the min and max of the whole array
  min_val = np.min(array)
  max_val = np.max(array)
  # Apply linear transformation
  scaled_array = (array - min_val) / (max_val - min_val) * (out_range[1] - out_range[0]) + out_range[0]
  return scaled_array
def standardImage(img):
  ''' get the absolute values of pixels and then normalize them'''
  img = np.abs(img)
  img = scale_array(img)
  return img

#convert image to an array anf cinvert type from uint8 to int
image  = asarray(ImageOps.grayscale(Image.open('q1.png'))).astype('int')

#backward gradient
d1_backward = standardImage(find_derivative(image,mode='backward', dir ='x'))
d2_backward = standardImage(find_derivative(image,mode='backward', dir ='y'))
d1d2_backward = standardImage(np.sqrt(np.power(d1_backward ,2)+np.power(d2_backward ,2)))

#forward gradient
d1_forward = standardImage(find_derivative(image,mode='forward', dir ='x'))
d2_forward = standardImage(find_derivative(image,mode='forward', dir ='y'))
d1d2_forward = standardImage(np.sqrt(np.power(d1_forward ,2)+np.power(d2_forward ,2)))

#cetral gradient
d1_central = standardImage(find_derivative(image,mode='central', dir ='x'))
d2_central = standardImage(find_derivative(image,mode='central', dir ='y'))
d1d2_central = standardImage(np.sqrt(np.power(d1_central ,2)+np.power(d2_central ,2)))

plt.imshow(image,cmap='gray')
plt.title('Original image')
plt.show()

#Show gradient as 9 images
fig = plt.figure(figsize=(10, 7))
rows = 3
columns = 3
fig.add_subplot(rows, columns, 1)
plt.imshow(d1_backward.astype("uint8"),cmap='gray')
plt.axis('off')
plt.title("$f_x$ for backward")
fig.add_subplot(rows, columns, 2)
plt.imshow(d2_backward.astype("uint8"),cmap='gray')
plt.axis('off')
plt.title("$f_y$ for backward")
fig.add_subplot(rows, columns, 3)
plt.imshow(d1d2_backward.astype("uint8"),cmap='gray')
plt.axis('off')
plt.title("$\sqrt{f(x)^2+f(y)^2}$ for backward")
#################################################
fig.add_subplot(rows, columns, 4)
plt.imshow(d1_forward.astype("uint8"),cmap='gray')
plt.axis('off')
plt.title("$f_x$ for forward")
fig.add_subplot(rows, columns, 5)
plt.imshow(d2_forward.astype("uint8"),cmap='gray')
plt.axis('off')
plt.title("$f_y$ for forward")
fig.add_subplot(rows, columns, 6)
plt.imshow(d1d2_forward.astype("uint8"),cmap='gray')
plt.axis('off')
plt.title("$\sqrt{f(x)^2+f(y)^2}$ for forward")
#################################################
fig.add_subplot(rows, columns, 7)
plt.imshow(d1_central.astype("uint8"),cmap='gray')
plt.axis('off')
plt.title("$f_x$ for central")
fig.add_subplot(rows, columns, 8)
plt.imshow(d2_central.astype("uint8"),cmap='gray')
plt.axis('off')
plt.title("$f_y$ for central")
fig.add_subplot(rows, columns, 9)
plt.imshow(d1d2_central.astype("uint8"),cmap='gray')
plt.axis('off')
plt.title("$\sqrt{f(x)^2+f(y)^2}$ for central")
plt.show()